<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>Tópico 2: Localizar-se num Sistema Linux</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body>
<section id="tópico-2-localizar-se-num-sistema-linux" class="level1">
<h1>Tópico 2: Localizar-se num Sistema Linux</h1>
<p><strong>Peso:</strong> 9</p>
<section id="o-básico-da-linha-de-comando" class="level2">
<h2>2.1: O Básico da Linha de Comando</h2>
<p><strong>Peso:</strong> 3</p>
<p>A maneira tradicional de interagir com um computador com Linux ‒ especialmente um servidor de rede ‒ é usando a <em>linha de comando</em>. A linha de comando apresenta o <em>prompt do shell</em> indicando que o sistema está pronto para receber instruções. Normalmente, o prompt terminado com o caractere <strong>$</strong> indica que é um usuário comum que está utilizando o sistema. Quando terminado com o caractere <strong>#</strong>, indica tratar-se do usuário <em>root</em>.</p>
<blockquote>
<p><strong>O usuário root</strong></p>
<p>O usuário root pode realizar todo tipo de operações no sistema. Por questões de segurança e privacidade, toda tarefa e arquivo têm um usuário “dono”. Cada usuário pode interferir apenas nas tarefas e arquivos que lhe pertencem. Já o usuário root pode interferir em qualquer tarefa ou arquivo.</p>
</blockquote>
<p>A linha de comando é aberta com um programa chamado <em>emulador de terminal</em>. Normalmente, é chamado apenas de <em>terminal</em> no menu de aplicativos.</p>
<section id="o-shell-bash" class="level3">
<h3>O shell Bash</h3>
<p>No ambiente de linha de comando, o <em>shell</em> é o programa que faz a intermediação entre o usuário e os recursos do computador, como se fosse um ambiente de programação em tempo real para executar tarefas. O shell padrão na maioria das distribuições Linux é o <strong>Bash</strong> (<em>Bourne Again Shell</em>), ao qual os procedimentos aqui apresentados referem-se.</p>
<p>Um comando do shell pode consistir somente no nome do programa que se quer executar. Além daqueles oferecidos pelos demais programas instalados no computador, estão disponíveis diversos comandos embutidos do shell. Um dos comandos embutidos mais simples é o <code>echo</code>, que simplesmente exibe um conteúdo na tela:</p>
<pre><code>$ echo Linux Essentials
Linux Essentials</code></pre>
<p>O sinal <code>$</code> é mostrado apenas para indicar o prompt do shell, não deve ser digitado. Após escrever o comando <code>echo Linux Essentials</code>, o comando deve ser enviado pressionando a tecla <em>Enter</em>. A resposta do comando será exibida logo abaixo do comando. Para evitar que o comando <code>echo</code> quebre a linha (coloque o prompt na linha de baixo) no final da saída, utiliza-se <code>echo -n Linux Essentials</code>. Para que o comando <code>echo</code> utilize caracteres especiais, deve ser informada a opção <code>-e</code>. Por exemplo, para criar uma quebra de linhas entre as duas palavras:</p>
<pre><code>$ echo -e &quot;Linux\nEssentials&quot;
Linux
Essentials</code></pre>
<p>O termo <code>\n</code> representa uma quebra de linha.</p>
<p>Alguns comandos podem usar tantas opções e argumentos que chegam a ocupar mais de uma linha. Para quebrar um comando em mais de uma linha, se utiliza o sinal <strong>\</strong> (barra invertida) antes de cada quebra de linha. Por exemplo, para quebrar o comando <code>find /usr/share/doc -ipath '*howto*' -type d -ctime -100 -exec ls -ld '{}' ';'</code> em duas linhas:</p>
<pre><code>$ find /usr/share/doc -ipath &#39;*howto*&#39; -type d \
-ctime -100 -exec ls -ld &#39;{}&#39; &#39;;&#39;</code></pre>
<p>O comando <code>find</code> é utilizado para localizar arquivos no sistema de arquivos e é um exemplo de programa que pode receber muitos argumentos e opções. Um argumento ou parâmetro de comando é um termo esperado pelo programa para realizar a ação desejada. No exemplo anterior, foi utilizado o argumento <code>/usr/share/doc</code> para indicar onde o <code>find</code> deveria iniciar a busca.</p>
<p>Uma opção de comando é uma letra ou palavra, normalmente precedida de um traço, que modifica o comportamento de um comando. No exemplo anterior, duas opções utilizadas foram <code>-ipath '*howto*&quot;</code> e <code>-type d</code>, que indicam alguns filtros do <code>find</code>.</p>
<p>O esperado para a maioria dos comandos é que produzam a saída com o resultado imediatamente após o pressionamento da tecla <em>Enter</em>. Dependendo das circunstâncias, a saída do comando pode demorar mais que o esperado. Caso um programa esteja demorando muito para terminar ou não se quer esperar sua conclusão por qualquer outro motivo, pressionar a combinação de teclas <strong>Ctrl</strong> + <strong>c</strong> fará com que o programa seja interrompido e o prompt do shell fique novamente disponível.</p>
</section>
<section id="variáveis" class="level3">
<h3>Variáveis</h3>
<p>As variáveis usadas no shell são semelhantes às usadas em linguagens de programação. Uma variável é um nome que guarda um valor, que pode ser letras ou números. Nomes de variáveis são limitados a caracteres alfanuméricos, ou seja, pode conter letras e números, mas deve sempre começar com uma letra. A atribuição de um valor para uma variável é feito com o sinal de igual, onde o nome da variável fica a esquerda e o conteúdo da variável fica a direita:</p>
<pre><code>$ lpi=&quot;Linux Professional Institute&quot;</code></pre>
<p>Não devem haver espaços antes ou depois do sinal de igual. Se houverem espaços no conteúdo da variável, é importante utilizar as aspas duplas ou simples para não confundir o shell. O valor de uma variável pode ser exibido colocando o sinal <code>$</code> à frente do nome:</p>
<pre><code>$ echo $lpi
Linux Professional Institute</code></pre>
<p>Variáveis podem ser criadas por usuários comuns ou pré-definidas pelo sistema operacional. Tanto as variáveis pré-definidas quanto variáveis definidas para a sessão atual podem ser utilizadas por programas para obter configurações importantes do sistema. Quando definidas numa sessão interativa do shell, as variáveis também são chamadas de <em>variáveis de ambiente</em>. O próprio shell utiliza variáveis de ambiente para definir diversas de suas configurações.</p>
<p>O shell interpreta a primeira palavra fornecida como um comando interno ou o nome de um programa. A localização para o programa precisa ser fornecida, a menos que este esteja localizado em um dos diretórios contidos na variável global <code>PATH</code>. Se o programa está no diretório atual e fora dos diretórios contidos em PATH, seu nome deve ser precedido por <code>./</code>, por exemplo <code>./script.sh</code>.</p>
<p>O conteúdo da variável <code>PATH</code> pode ser exibido com o comando <code>echo</code>:</p>
<pre><code>$ echo $PATH
/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin</code></pre>
<p>Caso o programa ou script esteja em um diretório que não consta na variável <code>PATH</code>, o usuário pode incluí-lo para seu uso próprio temporariamente, até o fim da sessão do shell. Isso evita a necessidade de especificar o caminho para o programa, como no caso do <code>./</code> em <code>./script.sh</code>, ou um caminho mais longo. Caso o programa esteja no diretório atual, primeiro pode ser utilizado o comando <code>pwd</code> para obter o caminho do diretório atual por extenso:</p>
<pre><code>$ pwd
/home/luciano</code></pre>
<p>O caminho <code>/home/luciano</code> pode ser incluído na variável <code>PATH</code> com o comando <code>export</code>:</p>
<pre><code>$ export PATH=/home/luciano:$PATH</code></pre>
<p>Dessa forma, até o fim da sessão atual do shell, a variável <code>PATH</code> terá um novo diretório:</p>
<pre><code>$ echo $PATH
/home/luciano:/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin</code></pre>
<p>Essa ação costuma ser necessária somente se o usuário escreve os próprios programas. Por padrão, todos os programas ficam nos diretórios originais definidos na variável <code>PATH</code>. A localização específica de um comando pode ser determinada com outro comando, <code>which</code>:</p>
<pre><code>$ which man
/usr/bin/man</code></pre>
<p>Outra maneira de determinar a localização de um comando no sistema de arquivos é utilizar o comando <code>type</code>:</p>
<pre><code>$ type man
man é /usr/bin/man</code></pre>
<p>Caso o comando informado seja um comando interno do Bash, a saída produzida pelo <code>type</code> será diferente:</p>
<pre><code>$ type echo
echo é um comando interno do shell</code></pre>
<p>No caso do programa <code>man</code>, o Bash foi capaz de identificar sua localização pois o diretório <code>/usr/bin</code> consta na variável <code>PATH</code>.</p>
<p>Todas as variáveis globais são escritas em letras maiúsculas. Em ambientes Unix, há diferença entre letras maiúsculas e minúsculas. Portanto, utilizar <em>Path</em> ou <em>path</em> não irá funcionar. As variáveis globais são criadas no carregamento do sistema e exportadas com o comando <code>export</code> para que estejam disponíveis em todas as sessões futuras do shell.</p>
<p>Existem diversas outras variáveis globais definidas ao iniciar o shell que podem orientar o comportamento dos programas. A variável <code>HISTFILE</code>, por exemplo, armazena o caminho para o histórico de comandos digitados. Por padrão, o histórico é armazenado no arquivo <code>.bash_history</code>, no diretório pessoal do usuário. O histórico é útil para recuperar comandos previamente digitados. Ao pressionar a seta para cima, os comandos digitados anteriormente são exibidos. Todo histórico de comandos é exibido com o comando <code>history</code>.</p>
</section>
<section id="substituição-de-comandos" class="level3">
<h3>Substituição de comandos</h3>
<p>A saída de um comando pode ser armazenada dentro de uma variável, usando as aspas invertidas:</p>
<pre><code>$ agora=`date`</code></pre>
<p>O comando <code>date</code> exibe a data e a hora do sistema. Nesse caso, a data e a hora foram armazenadas na variável <code>agora</code>, cujo conteúdo pode ser exibido com o comando <code>echo</code>:</p>
<pre><code>$ echo $agora
seg fev 25 21:38:15 -03 2019</code></pre>
<p>É possível também usar a saída de um comando como argumento para outro, usando aspas invertidas:</p>
<pre><code>$ echo &quot;A data atual é `date`&quot;
A data atual é seg fev 25 21:38:54 -03 2019</code></pre>
<p>Alternativamente, pode ser usado o formato <code>$()</code> no lugar das aspas simples. O mesmo resultado dos exemplos anteriores seria obtido com <code>$(date)</code> no lugar de <code>`date`</code>.</p>
</section>
<section id="englobamento" class="level3">
<h3>Englobamento</h3>
<p>As operações com arquivos e diretórios permitem o uso de caracteres curinga, que são padrões de substituição de caracteres. O caractere <code>*</code> substitui qualquer sequência de caracteres:</p>
<pre><code>$ ls /etc/host*
/etc/host.conf  /etc/hostname  /etc/hosts  /etc/hosts.allow  /etc/hosts.deny</code></pre>
<p>O caractere <code>?</code> substitui apenas um caractere:</p>
<pre><code>$ ls /dev/sda?
/dev/sda1  /dev/sda2  /dev/sda3  /dev/sda4</code></pre>
<p>O uso de colchetes permite indicar uma lista de caracteres:</p>
<pre><code>$ ls /dev/hd[abc]
/dev/hda /dev/hdb /dev/hdc</code></pre>
<p>Chaves indicam uma lista de termos separados por vírgula:</p>
<pre><code>$ ls /dev/{hda,fdO}
/dev/fdO /dev/hda</code></pre>
<p>O uso de exclamação antes de um curinga o exclui da operação:</p>
<pre><code>ls /dev/tty[!56789]
/dev/tty0  /dev/tty1  /dev/tty2  /dev/tty3  /dev/tty4</code></pre>
<p>Curingas precedidos de barra invertida (<code>\</code>) não realizam substituição. São denominados caracteres <em>escapados</em>. Entre aspas duplas, apenas os caracteres especiais <code>(`)</code> e <code>$</code> têm efeito. Entre aspas simples, nenhum caractere especial tem efeito.</p>
</section>
<section id="comandos-sequenciais" class="level3">
<h3>Comandos sequenciais</h3>
<p>A grande maioria das tarefas depende da execução de mais de um comando. Para executar três comandos em sequência, independente do resultado de cada um, utiliza-se o formato:</p>
<pre><code>comando1 ; comando2 ; comando3</code></pre>
<p>Executar o comando seguinte apenas se o anterior foi bem sucedido (se retornou 0):</p>
<pre><code>comando1 &amp;&amp; comando2 &amp;&amp; comando3</code></pre>
<p>Executar o comando seguinte apenas se o anterior não foi bem sucedido (se retornou diferente de 0):</p>
<pre><code>comando1 || comando2 || comando3</code></pre>
<p>Todos os comandos obedecem à essas formas padronizadas de utilização. No entanto, cada comando possui uma finalidade e opções diferentes, sendo necessário consultar a sua documentação para conhecer detalhadamente sua utilização.</p>
</section>
</section>
<section id="utilizando-a-linha-de-comando-para-obter-ajuda" class="level2">
<h2>2.2: Utilizando a Linha de Comando para Obter Ajuda</h2>
<p><strong>Peso:</strong> 2</p>
<p>Em função do grande número de comandos disponíveis no ambiente Linux, é bastante difícil memorizar a finalidade de todos os comandos e opções. Para facilitar a digitação de um comando ou de um caminho existente, o shell oferece o recurso de autocompletar, acionado com a tecla <em>[TAB]</em>. Após digitar as primeiras letras de um comando ou caminho de diretório, a tecla <code>[TAB]</code> completa a linha de acordo com os comandos e caminhos encontrados.</p>
<p>Muitas das dúvidas a respeito da utilização de um comando podem ser sanadas ao fornecer a opção <code>--help</code> ao próprio comando. Contudo, a fonte de informação mais completa sobre um programa encontra-se em seu manual. Praticamente todos os comandos e arquivos de configuração no Linux acompanham um manual. Esse manual está acessível por intermédio do comando <code>man</code>, que demonstra em detalhes as funções do item em questão. Para ver um manual, basta usar o comando <code>man</code>, tendo o comando ou arquivo como argumento.</p>
<blockquote>
<p><strong>O comando info</strong></p>
<p>O comando <code>info</code> é uma espécie de alternativa aos manuais <code>man</code>. Além do comando <code>man</code>, pode haver documentação disponível pelo <code>info</code>. Em geral, informações disponíveis em páginas <em>info</em> também estão disponíveis em páginas de manual, porém de forma menos detalhada. Por padrão, os arquivos desse tipo de documentação são armazenadas em <code>/usr/share/info</code>.</p>
</blockquote>
<p>Em sua maioria, os manuais têm a seguinte organização:</p>
<ul>
<li><strong>Nome</strong>: Assunto do manual seguido por uma descrição breve;</li>
<li><strong>Sinopse</strong>: A sintaxe do comando;</li>
<li><strong>Descrição</strong>: Descrição detalhada;</li>
<li><strong>Opções</strong>: Revisão de todas as opções e suas funções;</li>
<li><strong>Arquivos</strong>: Arquivos relacionados ao assunto;</li>
<li><strong>Veja também</strong>: Outros manuais relacionados ao tópico.</li>
</ul>
<p>A navegação dentro do manual pode ser feita com as setas do teclado e com as teclas <em>Page Up</em> e <em>Page Down</em>. Também é possível fazer uma busca textual ao pressionar a tecla <strong>/</strong> (barra), que abre um campo na parte de baixo do terminal para digitar o termo a ser buscado. A busca é então realizada ao pressionar <em>Enter</em>. Para localizar a próxima ocorrência, basta pressionar a tecla <strong>n</strong>. Para encontrar a ocorrência anterior, basta pressionar a tecla <strong>?</strong>. Pressionar a tecla <strong>q</strong> finalizar o leitor do manual e retorna para o prompt do shell.</p>
<blockquote>
<p><strong>Procurar por manuais</strong></p>
<p>É possível buscar ocorrências de um termo na seção <em>nome</em> dos manuais com o comando <code>apropos</code>. Esse comando retorna a uma descrição breve para cada ocorrência encontrada e o nome do respectivo comando ou arquivo.</p>
</blockquote>
<p>Uma maneira de localizar os manuais de referência para um determinado programa é usar o comando <code>whatis</code>. O banco de dados do comando <code>whatis</code> armazena a seção <em>nome</em> dos manuais do sistema. O banco de dados geralmente é atualizado por um agendamento de sistema. Para cada recurso de manual localizado, o <code>whatis</code> mostra uma breve descrição:</p>
<pre><code>$ whatis man
man (1)              - an interface to the on-line reference manuals
man (7)              - macros to format man pages</code></pre>
<p>Os números entre parênteses referem-se à seção a qual pertence o manual. As seções existentes são listadas a seguir:</p>
<ul>
<li><strong>Seção 1</strong>: Programas disponíveis ao usuário;</li>
<li><strong>Seção 2</strong>: Funções de Sistema Unix e C;</li>
<li><strong>Seção 3</strong>: Funções de bibliotecas da linguagem C;</li>
<li><strong>Seção 4</strong>: Arquivos especiais (dispositivos em /dev);</li>
<li><strong>Seção 5</strong>: Convenções e formatos de arquivos;</li>
<li><strong>Seção 6</strong>: Jogos;</li>
<li><strong>Seção 7</strong>: Diversos (macros textuais etc.);</li>
<li><strong>Seção 8</strong>: Procedimentos administrativos (daemons, etc).</li>
</ul>
<p>Para acessar um item em uma seção específica, o número da seção precede o nome do item. Por exemplo, acessar o manual de <code>printf</code> na seção número 3:</p>
<pre><code>man 3 printf</code></pre>
<p>Por padrão, os arquivos dos manuais são armazenadas em <code>/usr/man</code> e <code>/usr/share/man</code>, em subdiretórios correspondentes à cada seção. Outros locais podem ser especificados com a variável <code>MANPATH</code>.</p>
<p>O comando <code>whereis</code> pode ser utilizado para localizar o arquivo do manual. Além disso, ele exibe o diretório onde está o comando e, se houver, o código fonte:</p>
<pre><code>$ whereis find
find: /usr/bin/find /usr/bin/X11/find /usr/share/man/man1/find.1.gz</code></pre>
<p>Para localizar arquivos e diretórios em geral, pode ser utilizado o comando <code>locate</code>. Um nome ou parte do caminho é fornecido como argumento, que exibirá todas as ocorrências correspondentes.</p>
<section id="outras-documentações" class="level3">
<h3>Outras documentações</h3>
<p>Projetos GNU geralmente incluem documentação como guias e exemplos de utilização. Esses documentos não têm um formato universal, mas podem ser oferecidos em texto puro, documentos HTML ou PDF. Estes arquivos podem ser encontrados em <code>/usr/share/doc</code>, em diretórios correspondentes aos programas.</p>
</section>
</section>
<section id="utilizando-diretórios-e-listando-arquivos" class="level2">
<h2>2.3: Utilizando Diretórios e Listando Arquivos</h2>
<p><strong>Peso:</strong> 2</p>
<p>À exceção do usuário administrador <em>root</em>, cujo diretório é <code>/root</code>, o diretório inicial é o diretório pessoal do usuário, localizado em <code>/home</code>, que leva o nome do usuário (utilizado para entrar no sistema). Para mudar de diretório, é utilizado o comando <code>cd</code>, seguido do caminho absoluto ou relativo para o diretório desejado.</p>
<p>Os caminhos para diretórios e arquivos podem ser acessados tanto por seu caminho absoluto quanto pelo relativo. Caminhos absolutos são aqueles iniciados pela barra da raiz (<code>/</code>) e caminhos relativos são aqueles que tomam por referência o diretório atual. O ponto (<code>.</code>) refere-se ao diretório atual, e os dois pontos (<code>..</code>) referem-se ao diretório que contém o diretório atual.</p>
<p>Sem argumentos, o comando <code>cd</code> leva para o diretório pessoal do usuário. Outra maneira de indicar o diretório pessoal é utilizar o sinal <code>~</code>. Este pode ser utilizado, por exemplo, para ir até um diretório no diretório pessoal, <code>cd ~/Documentos</code>, ou para indicar um arquivo no diretório pessoal, <code>ls ~/Documentos/doc.txt</code>.</p>
<p>O comando <code>ls</code> é usado para listar arquivos e conteúdo de um diretório. A opção <code>-l</code> exibe detalhes sobre o(s) arquivo(s), <code>-s</code> mostra o tamanho em bytes e <code>-d</code> mostra as propriedades de um diretório, não seu conteúdo. Exemplo de saída de <code>ls -l</code>:</p>
<pre><code>$ ls -l /
total 64
lrwxrwxrwx    1 root root     7 fev  7  2018 bin -&gt; usr/bin
dr-xr-xr-x.   7 root root  4096 fev 26 10:06 boot
drwxr-xr-x   20 root root  4300 fev 26 10:10 dev
drwxr-xr-x. 194 root root 12288 fev 26 10:10 etc
drwxr-xr-x.   4 root root  4096 fev  7  2018 home
lrwxrwxrwx    1 root root     7 fev  7  2018 lib -&gt; usr/lib
lrwxrwxrwx    1 root root     9 fev  7  2018 lib64 -&gt; usr/lib64
drwx------    2 root root 16384 nov 15  2016 lost+found
drwxr-xr-x.   2 root root  4096 fev  7  2018 media
drwxr-xr-x.   2 root root  4096 set 18 00:04 mnt
drwxr-xr-x.   4 root root  4096 fev  7  2018 opt
dr-xr-xr-x  209 root root     0 fev 26 10:08 proc
dr-xr-x---.  27 root root  4096 fev 26 10:53 root
drwxr-xr-x   53 root root  1560 fev 26 11:08 run
lrwxrwxrwx    1 root root     8 fev  7  2018 sbin -&gt; usr/sbin
drwxr-xr-x.   2 root root  4096 fev  7  2018 srv
dr-xr-xr-x   13 root root     0 fev 26 10:10 sys
drwxrwxrwt   14 root root   320 fev 26 12:13 tmp
drwxr-xr-x.  14 root root  4096 ago 28 08:41 usr
drwxr-xr-x.  26 root root  4096 ago 30 12:43 var</code></pre>
<p>Diversas informações são exibidas à esquerda do nome de cada item, como as permissões de acesso, o usuário dono do arquivo e a data de modificação.</p>
<p>Arquivos que começam com um ponto “.” não são exibidos pelo comando <code>ls</code>. Para que esses arquivos também sejam exibidos, é necessário utilizar o <code>ls</code> com a opção <code>-a</code>. Também é possível utilizar englobamento nas listagens. Por exemplo, para listar todos os arquivos que terminem com o sufixo <em>.txt</em>, utiliza-se <code>ls *.txt</code>.</p>
<p>Para obter uma lista com os conteúdos de todos os subdiretórios, pode ser utilizado o comando <code>ls -R</code> ou o comando <code>find</code>. O principal comando de localização de arquivos em linha de comando é o <code>find</code>, cuja sintaxe básica é <em>find diretório critério</em>.</p>
<p>O argumento <code>diretório</code> indica onde o <code>find</code> deve iniciar a busca, e o <code>critério</code> pode ser o nome do arquivo ou diretório a ser procurado ou uma regra para a busca. Existem dezenas de critérios de busca, os mais comuns são:</p>
<ul>
<li><code>-type x</code>: A letra <em>x</em> define o tipo do arquivo (<em>d</em> para diretório, <em>f</em> para arquivo comum e <em>l</em> para link simbólico).</li>
<li><code>-name nome</code>: O nome do arquivo. Pode ser um nome parcial, como <em>‘foto*’</em>, para localizar todos os nomes que começam com o termo <em>foto</em>. É recomendável utilizar as aspas simples nesse caso.</li>
<li><code>-user usuário</code>: O usuário dono do arquivo.</li>
<li><code>-atime -/+n</code>: Arquivo acessado antes ou após <em>n</em>. <em>n</em> corresponde à expressão <em>n * 24 horas</em>. Ou seja, se for utilizado <code>-atime -1</code> serão listados os arquivos acessados a menos de 24 horas. Se for utilizado <code>-atime +2</code>, serão listados os arquivos acessados a mais de 48 horas.</li>
<li><code>-ctime -/+n</code>: Arquivo criado antes ou após <em>n</em>. Vale o mesmo princípio do <code>-atime</code>.</li>
<li><code>-mtime -/+n</code>: Arquivo modificado antes ou depois de <em>n</em>. Vale o mesmo princípio do <code>-atime</code>.</li>
<li><code>-amin -/+n</code>: Arquivo acessado antes ou depois de <em>n</em>. <em>n</em> corresponde à quantidade de minutos. Por exemplo, <code>-amin -15</code> irá listar todos os arquivos acessados a menos de 15 minutos. Com <code>-amin +30</code>, serão listados os arquivos acessados a mais de 30 minutos.</li>
<li><code>-cmin -/+n</code>: Arquivo criado antes ou depois de <em>n</em>. Vale o mesmo princípio de <code>-amin</code>.</li>
<li><code>-mmin -/+n</code>: Arquivo modificado antes ou depois de <em>n</em>. Vale o mesmo princípio de <code>-amin</code>.</li>
<li><code>-newer arquivo</code>: O arquivo procurado foi criado ou modificado após <em>arquivo</em>.</li>
<li><code>-perm modo</code>: O arquivo procurado tem permissão especificada igual a modo, como as letras <em>r</em>, <em>w</em> e <em>x</em>.</li>
<li><code>-perm -modo</code>: O arquivo procurado tem todas as permissões listadas em modo.</li>
<li><code>-perm +modo</code>: O arquivo procurado tem qualquer das permissões listadas em modo.</li>
</ul>
<p>O <code>find</code> pode ser utilizado, por exemplo, para obter uma lista com todos os arquivos criados no diretório pessoal ou em seus subdiretórios nas últimas 24 horas:</p>
<pre><code>$ find /usr/lib -type f -ctime -1</code></pre>
<p>A opção <code>-find f</code> determina que sejam buscados somente arquivos (excluindo diretórios e outros arquivos especiais) e a opção <code>-ctime -1</code> determina que a data de criação dos arquivos seja inferior a 1 dia em relação a data atual.</p>
</section>
<section id="criar-mover-e-apagar-arquivos" class="level2">
<h2>2.4: Criar, mover e apagar arquivos</h2>
<p><strong>Peso:</strong> 2</p>
<p>O comando <code>cp</code> é utilizado para copiar arquivos. Suas opções principais são:</p>
<ul>
<li><code>-i</code>: Modo interativo. Pergunta antes de sobrescrever um arquivo.</li>
<li><code>-p</code>: Copia também os atributos do arquivo original.</li>
<li><code>-r</code>: Copia recursivamente o conteúdo do diretório de origem.</li>
</ul>
<p>É importante saber que ao copiar um diretório recursivamente, o uso da barra <code>/</code> no final do diretório de origem fará com que apenas o conteúdo do diretório seja copiado para o destino; não usar a barra fará com que o diretório de origem e seu conteúdo sejam copiados no destino.</p>
<p>O comando <code>mv</code> move e renomeia arquivos e diretórios. Usado com a opção <code>-i</code>, ele pede confirmação antes de sobrescrever um arquivo de destino.</p>
<p>Um arquivo vazio pode ser criado com o comando <code>touch</code>. Por exemplo, <code>touch arquivo.txt</code> cria o arquivo vazio <code>arquivo.txt</code>. O comando <code>touch</code> também pode ser utilizado apenas para alterar a data de um arquivo. Usado sem argumentos, <code>touch</code> altera a data e a hora de criação e modificação de um arquivo para os valores atuais do sistema. Para alterar apenas a data de modificação, usa-se a opção <code>-m</code>, e para alterar apenas a data de acesso, usa-se a opção <code>-a</code>. Outros valores de tempo podem ser passados com a opção <code>-t</code>.</p>
<p>O comando <code>mkdir</code> cria diretórios. Para criar uma árvore de diretórios recursivamente, sem necessidade de criar um a um, usa-se a opção <code>-p</code>:</p>
<pre><code>mkdir -p caminho/completo/para/diretório</code></pre>
<p>Para alterar as permissões do diretório no ato da criação, as mesmas são transmitidas ao <code>mkdir</code> com a opção <code>-m</code>. Diretórios vazios podem ser apagados pelo comando <code>rmdir</code>. Com a opção <code>-p</code>, o <code>rmdir</code> remove o diretório indicado e os diretórios superiores, desde que estejam vazios.</p>
<p>Para apagar um arquivo, o comando é <code>rm</code>. Para apagar diretórios com conteúdo, usa-se <code>rm -r</code>. Para forçar a remoção, a opção <code>-f</code> é utilizada.</p>
</section>
</section>
</body>
</html>

