<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>Tópico 3: O Poder da Linha de Comando</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body>
<section id="tópico-3-o-poder-da-linha-de-comando" class="level1">
<h1>Tópico 3: O Poder da Linha de Comando</h1>
<p><strong>Peso:</strong> 9</p>
<section id="armazenamento-de-arquivos-na-linha-de-comando" class="level2">
<h2>3.1: Armazenamento de arquivos na linha de comando</h2>
<p><strong>Peso:</strong> 2</p>
<p>Praticamente toda operação realizada no computador envolve a manipulação de arquivos, que muitas vezes precisarão ser transportados ou armazenados em diferentes locais. Nesses casos, é conveniente gerar um arquivo contendo diretórios e outros arquivos, de modo a facilitar seu transporte e otimizar a ocupação de espaço em disco.</p>
<p>No Linux, o principal comando para agregar diferentes arquivos é o comando <code>tar</code>. Originalmente desenvolvido para armazenar cópias de segurança em fita, hoje o <code>tar</code> também é utilizado para facilitar o armazenamento e distribuição de arquivos em diferentes mídias.</p>
<section id="utilizando-o-tar" class="level3">
<h3>Utilizando o tar</h3>
<p>Para criar um arquivo contendo todo o diretório <code>/etc</code> e seu conteúdo com o <code>tar</code>, podemos usar o comando:</p>
<pre><code>tar cvf etc.tar /etc</code></pre>
<p>Diferente de outros comandos, a inclusão do traço antes das opções do <code>tar</code> é facultativa. As opções fornecidas no exemplo representam:</p>
<ul>
<li><code>c</code>: Criar um arquivo;</li>
<li><code>v</code>: Mostrar cada arquivo conforme é incluído;</li>
<li><code>f</code>: Especifica o arquivo a ser criado, informado em seguida.</li>
</ul>
<p>O último argumento é o diretório(s) ou arquivo(s) a ser incluído. Para extrair o conteúdo de um arquivo tar, a opção usada é a <code>x</code>:</p>
<pre><code>tar xvf etc.tar</code></pre>
<p>Os arquivos serão extraídos com a árvore de diretórios completa. Este arquivo <em>.tar</em>, apesar de agregar vários arquivos, não está comprimido.</p>
</section>
<section id="compressão" class="level3">
<h3>Compressão</h3>
<p>Os principais comandos de compressão no Linux são o <code>gzip</code> e o <code>bzip2</code>. Para compactar um arquivo com <em>gzip</em>:</p>
<pre><code>gzip etc.tar</code></pre>
<p>Para comprimir com <em>bzip2</em>:</p>
<pre><code>bzip2 etc.tar</code></pre>
<p>Será criado automaticamente o arquivo <code>etc.tar.gz</code> ou <code>etc.tar.bz2</code>. A principal diferença entre as duas modalidades de compressão é o algorítimo utilizado. O gzip é mais rápido, enquanto que o bzip2 costuma oferecer melhores taxa de compressão.</p>
<p>A compressão pode ser especificada diretamente com o comando <code>tar</code>. Para realizar a compressão com <em>gzip</em>, é utilizada a opção <code>z</code>:</p>
<pre><code>tar czvf etc.tar.gz /etc</code></pre>
<p>Para usar <em>bzip2</em>, é utilizada a opção <code>j</code>:</p>
<pre><code>tar cjvf etc.tar.bz2 /etc</code></pre>
<p>A descompressão pode ser feita com os comandos <code>gunzip</code> (ou <code>gzip -d</code>) e <code>bunzip2</code> (ou <code>bzip2 -d</code>), mas também pode ser feita diretamente com o comando <code>tar</code> e com as opções <code>z</code> e <code>j</code>, respectivamente.</p>
</section>
<section id="arquivos-zip" class="level3">
<h3>Arquivos zip</h3>
<p>Outro formato popular para comprimir arquivos é formato <em>zip</em>. Esse tipo de arquivo também pode ser criado pela linha de comando, com o comando <code>zip</code>. Assim como o comando <code>tar</code>, o comando <code>zip</code> aceita caracteres especiais para selecionar os arquivos que serão incluídos:</p>
<pre><code>zip documentos.zip *pdf</code></pre>
<p>Neste exemplo, será criado o arquivo <em>documentos.zip</em> contendo todos os arquivos do diretório atual terminados com o sufixo <em>pdf</em>. Para extrair o conteúdo deste arquivo, é utilizado o comando <code>unzip documentos.zip</code>, que criará os arquivos extraídos no diretório atual. Para extrair os arquivos para outra pasta, deve ser utilizada a opção <code>-d diretório</code>, onde <em>diretório</em> é o diretório que receberá os arquivos extraídos.</p>
</section>
</section>
<section id="procurar-e-extrair-informações-de-arquivos" class="level2">
<h2>3.2: Procurar e Extrair Informações de Arquivos</h2>
<p><strong>Peso:</strong> 3</p>
<p>Um dos comandos mais básicos para examinar o conteúdo de arquivos de texto é o comando <code>less</code>. O <code>less</code> simplesmente exibe na tela o conteúdo de um arquivo informado como argumento. Por exemplo, o conteúdo do arquivo <code>/proc/cpuinfo</code>, que contém detalhes sobre o processador do computador, será exibido com o comando <code>less /proc/cpuinfo</code>.</p>
<p>Caso o tamanho do arquivo seja maior que o espaço disponível em tela, as teclas de direção para cima e para baixo do teclado podem ser utilizadas para navegação no arquivo. O <code>less</code> também permite fazer buscas de texto ao pressionar a tecla <strong>/</strong> (barra) no teclado, que permite digitar o texto buscado na parte de baixo da tela e iniciar a procura ao pressionar <em>Enter</em>. Para localizar a próxima ocorrência, basta pressionar a tecla <strong>n</strong>. Para encontrar a ocorrência anterior, basta pressionar a tecla <strong>?</strong>. Pressionar a tecla <strong>q</strong> finalizar o <code>less</code> e retorna para o prompt do shell.</p>
<section id="redirecionamento" class="level3">
<h3>Redirecionamento</h3>
<p>Processos Unix (e Linux) por padrão abrem três canais de comunicação, que os permitem receber e emitir dados. Esses dados, que podem ser um texto legível ou dados binários como áudio e vídeo, podem ser redirecionados de e para outros arquivos ou processos. No caso de programas interativos, o canal de entrada (chamado <em>standard input</em> ou <em>stdin</em>) costuma ser o próprio teclado. Os canais de saída-padrão (<em>standard output</em> ou <em>stdout</em>) e de saída de erro (<em>standard error</em> ou <em>stderr</em>) costumam ser a tela do computador. Os valores numéricos para esses canais são <strong>0</strong> para <em>stdin</em>, <strong>1</strong> para <em>stdout</em> e <strong>2</strong> para <em>stderr</em>. Esses descritores são automaticamente definidos pelos dispositivos virtuais localizados no diretório <code>/dev</code>: <code>/dev/stdin</code>, <code>/dev/stdout</code> e <code>/dev/stderr</code>.</p>
<p>O fluxo dos dados para redirecionamentos e canalizações numa linha de comando acontece da esquerda para a direita. Para redirecionar a saída-padrão de um comando para um arquivo, utiliza-se o caractere <strong>&gt;</strong> após este, que deve indicar o arquivo que receberá os dados em questão. Por exemplo, pode-se redirecionar o conteúdo do arquivo <code>/proc/cpuinfo</code> com o comando:</p>
<pre><code>cat /proc/cpuinfo &gt; ~/cpu.txt</code></pre>
<p>A finalidade do comando <code>cat</code> é semelhante à do <code>less</code>, mas o <code>cat</code> envia um conteúdo para a saída padrão de modo não interativo. No exemplo, a saída do <code>cat</code> é o conteúdo do arquivo <code>/proc/cpuinfo</code>, que foi redirecionado para o arquivo <code>cpu.txt</code> no diretório pessoal do usuário. Se o arquivo <code>~/cpu.txt</code> já existe, será sobrescrito. Para adicionar os valores sem apagar o conteúdo existente, usa-se <strong>&gt;&gt;</strong> no lugar de <strong>&gt;</strong>.</p>
<p>O conteúdo redirecionado por padrão é o de <em>stdout</em>. Para especificar <em>stderr</em>, usa-se <strong>2&gt;</strong>. Para redirecionar ambos simultaneamente, usa-se <strong>&amp;&gt;</strong>.</p>
</section>
<section id="canalização" class="level3">
<h3>Canalização</h3>
<p>Parte da filosofia Unix é que cada programa tenha uma finalidade específica e evite tentar desempenhar todas as tarefas sozinho. Nesse contexto, é possível encadear a execução de comandos individuais, cada um desempenhando sua função, para obter um resultado combinado. Esse encadeamento consiste em enviar a saída de um comando para a entrada de outro comando utilizando o caractere de canalização <strong>|</strong>, chamado <em>pipe</em>.</p>
<p>Por exemplo, o conteúdo do arquivo <code>/proc/cpuinfo</code> pode ser direcionado para o comando <code>wc</code> com o comando:</p>
<pre><code>$ cat /proc/cpuinfo | wc
   208    1184    6096</code></pre>
<p>O conteúdo do arquivo <code>/proc/cpuinfo</code> foi redirecionado para a entrada padrão do comando <code>wc</code>, que faz a contagem do número de linhas, palavras e caracteres de um arquivo ou do conteúdo recebido pela entrada padrão. O mesmo resultado do exemplo é obtido ao substituir o uso do <code>cat</code> pelo operador de redirecionamento <strong>&lt;</strong>:</p>
<pre><code>$ wc &lt; /proc/cpuinfo
   208    1184    6096</code></pre>
<p>O redirecionamento com <strong>&lt;</strong> é específico para enviar o conteúdo de um arquivo para a entrada padrão de um programa. Neste caso, o fluxo dos dados segue da direita para a esquerda. Via de regra, os comandos que lidam com conteúdos de texto dispensam o uso desse operador, bastando informar a localização do arquivo.</p>
<p>Várias canalizações podem ser feitas em sequência. A seguir, duas canalizações usadas numa mesma linha de comando:</p>
<pre><code>$ cat /proc/cpuinfo | grep &#39;model name&#39; | uniq
model name      : Intel(R) Xeon(R) CPU           X5355  @ 2.66GHz</code></pre>
<p>O conteúdo do arquivo <code>/proc/cpuinfo</code> foi canalizado com o comando <code>cat /proc/cpuinfo</code> para o comando <code>grep 'model name'</code>, que selecionará apenas as linhas contendo o termo <em>model name</em>. Por tratar-se de um computador com vários processadores, há várias linhas <em>model name</em> iguais. A última canalização é do comando <code>grep 'model name'</code> para o comando <code>uniq</code>, que reduz linhas repetidas em sequência para apenas uma ocorrência.</p>
</section>
<section id="expressões-regulares" class="level3">
<h3>Expressões regulares</h3>
<p>Expressões regulares são elementos de texto e operadores que formam um padrão, usado para encontrar e opcionalmente alterar um padrão correspondente. As expressões regulares são suportadas por uma grande variedade de programas que lidam com texto e que compartilham o os principais operadores, listados a seguir:</p>
<ul>
<li><code>^</code>: Começo de linha.</li>
<li><code>$</code>: Fim de linha.</li>
<li><code>.</code>: Qualquer caractere.</li>
<li><code>*</code>: Qualquer sequência com tamanho igual ou superior a zero do caractere precedente.</li>
<li><code>?</code>: Uma ou nenhuma ocorrência do caractere precedente.</li>
<li><code>[]</code>: Qualquer caractere que esteja presente nos colchetes.</li>
</ul>
<p>Um dos principais programas que utiliza expressões regulares para realizar buscas em texto é o <code>grep</code>, cuja aplicação mais comum é filtrar e facilitar a inspeção de arquivos muito longos. Pode ser utilizado, por exemplo, para analisar o conteúdo do arquivo <code>/etc/services</code>, que contém as definições de portas associadas a serviços de rede:</p>
<pre><code>$ cat /etc/services | grep &#39;^..tp *.../tcp&#39;
lmtp            24/tcp                          # LMTP Mail Delivery
smtp            25/tcp          mail
tftp            69/tcp
http            80/tcp          www www-http    # WorldWideWeb HTTP
sftp            115/tcp
nntp            119/tcp         readnews untp   # USENET News Transfer Protocol
qmtp            209/tcp                         # Quick Mail Transfer Protocol
bftp            152/tcp                 # Background File Transfer Program
pftp            662/tcp                 # PFTP
dctp            675/tcp                 # DCTP
vatp            690/tcp                 # Velneo Application Transfer Protocol</code></pre>
<p>É importante que a expressão esteja indicada com as aspas simples, para evitar que seja indevidamente interpretada pelo Bash.</p>
<p>O operador colchetes permite indicar uma sequência implícita de caracteres. Por exemplo, o operador <code>[a-z]</code> corresponde a qualquer letra do alfabeto, de <em>a</em> a <em>z</em>:</p>
<pre><code>$ fdisk -l | grep &#39;^Disco /dev/sd[a-z]&#39;
Disco /dev/sda: 29,8 GiB, 32017047552 bytes, 62533296 setores
Disco /dev/sdb: 298,1 GiB, 320072933376 bytes, 625142448 setores
Disco /dev/sdc: 931,5 GiB, 1000170586112 bytes, 1953458176 setores</code></pre>
<p>O comando <code>fdisk -l</code> gerou as informações detalhadas a respeito de partições nos disco presentes no sistema e enviou para a entrada padrão do <code>grep</code>, que por sua vez selecionou somente as linhas iniciando com a palavra <em>Disco</em> seguidas do caminho <em>/dev/sd[a-z]</em>, correspondente a qualquer caminho terminando com uma letra do alfabeto.</p>
<p>O <code>grep</code> aceita diversas opções que modificam seu comportamento. Alguma opções comuns são:</p>
<ul>
<li><code>-c</code>: Conta as linhas contendo o padrão.</li>
<li><code>-i</code>: Ignora a diferença entra maiúsculas e minúsculas.</li>
<li><code>-f</code>: Usa a expressão regular contida no arquivo indicado por essa opção.</li>
<li><code>-n</code>: Procura somente na linha indicada por essa opção.</li>
<li><code>-v</code>: Mostra todas as linhas exceto as que correspondem ao padrão.</li>
</ul>
<p>Dois comandos complementam as funções do grep: <code>egrep</code> e <code>fgrep</code>. O comando <code>egrep</code> é equivalente ao comando <code>grep -E</code>, que incorpora outras funcionalidades além das expressões regulares padrão. Com o <code>egrep</code> pode-se usar o operador <em>pipe</em>, que atua como o operador <em>OU</em>. Desse modo, a expressão ‘invenção|invenções’ corresponde a todas as ocorrências do termo <em>invenção</em> ou <em>invenções</em>.</p>
<p>Já o <code>fgrep</code> age da mesma forma que o <code>grep -F</code>, ou seja, ele deixa de interpretar expressões regulares. É especialmente útil nos casos mais simples, quando se quer apenas localizar a ocorrência de algum texto simples. Mesmo se forem utilizados caracteres especiais, como <code>$</code> ou o ponto, estes serão interpretados literalmente, e não pelo que representam numa expressão regular.</p>
</section>
<section id="manipulando-conteúdo-de-arquivos" class="level3">
<h3>Manipulando conteúdo de arquivos</h3>
<p>Existem muitos outros comandos que trabalham com arquivos de conteúdo de texto, basicamente realizando tarefas de recortar, extrair e filtrar. Vários desses comandos são fornecidos pelo pacote <em>GNU coreutils</em>.</p>
<p>O comando <code>tac</code> tem a mesma função do <code>cat</code>, mas mostra o conteúdo de trás para frente.</p>
<p>O comando <code>sort</code> ordena alfabeticamente. Com a opção <code>-n</code>, ordena numericamente. A opção <code>-r</code> inverte o resultado.</p>
<p>O comando <code>head</code> mostra o começo de arquivos. Por padrão, as primeiras dez linhas são mostradas. A quantidade de linhas a serem mostradas é indicada pela opção <code>-n</code>. A opção <code>-c</code> especifica o número de caracteres (<em>bytes</em>) a serem mostrados.</p>
<p>O comando <code>tail</code> mostra o final de arquivos. Por padrão, as últimas dez linhas são exibidas. A quantidade de linhas a serem mostradas é indicada pela opção <code>-n</code>. A opção <code>-c</code> especifica o número de caracteres (bytes) a serem exibidos. Para que o final do arquivo seja mostrado continuamente, à medida que mais texto é adicionado, usa-se a opção <code>-f</code> (de <em>follow</em>). O sinal <strong>+</strong> indica que a leitura deve ser feita a partir da linha especificada após o <strong>+</strong>.</p>
<p>O comando <code>wc</code> conta linhas, palavras ou caracteres, a partir das opções <code>-l</code>, <code>-w</code> e <code>-c</code>, respectivamente. Quando usado sem argumentos, mostra esses três valores na mesma sequência.</p>
<p>O comando <code>cut</code> delimita um arquivo em colunas, em determinado número de caracteres ou por posição de campo. Para separar por campo, a opção <code>-d</code> especifica o caractere delimitador e <code>-f</code> informa a posição do campo. Por exemplo, para mostrar os campos da posição 1 e 3 do arquivo <code>/etc/group</code>, que estão separados por “<code>:</code>”:</p>
<pre><code>$ cut -d &#39;:&#39; -f 1,3 /etc/group
root:0
daemon:1
bin:2
sys:3
adm:4
(...)</code></pre>
<p>Para exibir outro delimitador no lugar do delimitador original, usa-se a opção <code>--output-deilimiter</code>:</p>
<pre><code>$ cut -d &#39;:&#39; -f 1,3 --output-delimiter &#39; = &#39; /etc/group
root = 0
daemon = 1
bin = 2
sys = 3
adm = 4
(...)</code></pre>
<p>O comando <code>paste</code> concatena arquivos lado a lado, na forma de colunas:</p>
<pre><code>$ cat um.txt
1       a1      a2      a3
2       b1      b2      b3
3       c1      c2      c3

$ cat dois.txt
1       x1      x2      x3
2       y1      y2      y3
3       z1      z2      z3

$ paste um.txt dois.txt
1       a1      a2      a3      1       x1      x2      x3
2       b1      b2      b3      2       y1      y2      y3
3       c1      c2      c3      3       z1      z2      z3</code></pre>
<p>Todos esses comandos podem ser combinados com canalizações e redirecionamentos. Mesmo quando se utiliza um processador de textos para editar um arquivo, os comandos podem ser úteis para realizar tarefas mais elaboradas ou repetitivas.</p>
</section>
</section>
<section id="converter-comandos-em-um-script" class="level2">
<h2>3.3: Converter comandos em um script</h2>
<p><strong>Peso:</strong> 4</p>
<p><em>Scripts</em> são arquivos que agem como programas, passando instruções a um interpretador para realizar determinada tarefa. Diferente de programas compilados, scripts são arquivos de texto que podem ser manipulados em qualquer editor de texto puro. No Linux, é bastante comum escrever <em>shell scripts</em>, que automatizam a execução de tarefas na linha de comando, das mais simples às mais sofisticadas. Cada linha do arquivo script será interpretada como um comando digitado no shell e deve respeitar as mesmas regras dos comandos digitados manualmente.</p>
<section id="editores-de-texto" class="level3">
<h3>Editores de texto</h3>
<p>Existem diversos editores de texto para linha de comando. O mais tradicional é o <strong>vi</strong>, mas existem alternativas como o <strong>pico</strong> e o <strong>nano</strong>. É recomendável conhecer minimamente o vi, pois é o editor encontrado em qualquer ambiente Unix.</p>
</section>
<section id="edição-com-vi" class="level3">
<h3>Edição com Vi</h3>
<p>O vi é considerado um editor para usuários experientes. Mesmo se comparado a outros editores de terminal, suas peculiaridades o tornam pouco intuitivo para usuários iniciantes.</p>
<p>A interface do vi se resume à tela onde o texto é apresentado e é manipulado, com um cursor indicando onde a ação é executada. Todas as operações são realizadas a partir de comandos do teclado. No <code>vi</code> existem os chamados modos de execução, nos quais as ações de teclado se comportam de maneira distinta. Há três modos de execução básicos no vi: O <em>modo de navegação</em>, o <em>modo de inserção</em> e o <em>modo de comando</em>.</p>
<p>O <strong>modo de navegação</strong> é o modo inicial do <code>vi</code>. Nele as teclas do teclado atuam basicamente para navegação e seleção de blocos de texto. Geralmente, os comandos são letras únicas. Se precedido por um número, o comando será repetido correspondentemente ao valor desse número.</p>
<p>A utilização do modo de navegação só faz sentido em um texto já existente ou após digitar algum conteúdo em um documento novo. Para abrir um arquivo, basta fornecer seu caminho como argumento ao comando <code>vi</code>. A seguir, alguns comandos de navegação importantes.</p>
<ul>
<li><strong>h</strong>: Posicionar o cursor uma posição à esquerda.</li>
<li><strong>j</strong>: Posicionar o cursor uma posição abaixo.</li>
<li><strong>k</strong>: Posicionar o cursor uma posição acima.</li>
<li><strong>l</strong>: Posicionar o cursor uma posição à direita.</li>
<li><strong>i</strong>, <strong>I</strong>: Entra no modo de inserção na posição atual do cursor ou no início da linha atual.</li>
<li><strong>a</strong>, <strong>A</strong>: Entra no modo de inserção depois do cursor ou no fim da linha.</li>
<li><strong>o</strong>, <strong>O</strong>: Adiciona linha e entra no modo de inserção na linha posterior ou anterior a do cursor.</li>
<li><strong>Esc</strong> Sair do modo de inserção e voltar para o modo de navegação.</li>
<li><strong>0</strong>, <strong>$</strong>: Ir para o início ou para o fim da linha.</li>
<li><strong>G</strong>: Posicionar o cursor no final do documento. Se precedido de um número, ir até a linha correspondente.</li>
<li><strong>(</strong>, <strong>)</strong>: Ir para o início ou fim da sentença.</li>
<li><strong>{</strong>, <strong>}</strong>: Ir para o início ou fim do parágrafo.</li>
<li><strong>w</strong>, <strong>W</strong>: Ir até o início da próxima palavra. Com <strong>W</strong>, ir até a próxima palavra descartando caracteres especiais.</li>
<li><strong>v</strong>, <strong>V</strong>: Seleciona texto com as teclas de navegação. O uso de <strong>V</strong> seleciona linhas completas.</li>
<li><strong>s</strong>, <strong>S</strong>: Entra no modo de inserção, substituindo o caractere sob o cursor ou a linha toda.</li>
<li><strong>c</strong>: Apaga o conteúdo selecionado e entra no modo de inserção.</li>
<li><strong>r</strong>: Substitui o caractere sob o cursor.</li>
<li><strong>x</strong>: Apaga o caractere sob o cursor.</li>
<li><strong>t</strong>: Posiciona o cursor antes do caractere informado.</li>
<li><strong>y</strong>, <strong>yy</strong>: Copia o conteúdo selecionado ou a linha toda.</li>
<li><strong>d</strong>, <strong>dd</strong>: Apaga o conteúdo selecionado ou toda a linha atual. O conteúdo removido é copiado.</li>
<li><strong>p</strong>, <strong>P</strong>: Cola o conteúdo copiado, após ou antes do cursor.</li>
<li><strong>u</strong>, <strong>[Ctrl][r]</strong>: Desfazer, refazer</li>
<li><strong>/</strong>, <strong>?</strong>: Buscar no texto a partir da posição atual ou antes da posição atual.</li>
<li><strong>ZZ</strong>: Fecha e salva, se necessário.</li>
<li><strong>ZQ</strong>: Fecha e não salva.</li>
</ul>
<p>Diversas teclas de navegação podem ser combinadas. Por exemplo, para apagar todo o conteúdo a partir da posição atual do cursor até o próximo ponto, basta pressionar as teclas <strong>dt.</strong>.</p>
<p>A finalidade do <strong>modo de inserção</strong> é simplesmente inserir texto. A tecla <strong>[Esc]</strong> sai do modo de inserção e volta para o modo de navegação.</p>
<p>O <strong>modo de comando</strong> é acionado ao pressionar a tecla <strong>:</strong> no modo de navegação. Usado para fazer buscas, alterações, salvar, sair, executar comandos no shell, alterar configurações do <code>vi</code>, etc. Para retornar ao modo de navegação, usa-se o comando <code>visual</code> ou simplesmente a tecla <strong>[Enter]</strong> com a linha vazia. A seguir, alguns comandos importantes do modo de comando:</p>
<ul>
<li><code>:!</code>: Permite executar comandos do shell. Para retornar ao vi, executar o comando <code>exit</code> ou pressionar <code>ctrl</code> + <code>d</code>.</li>
<li><code>:quit</code> ou <code>:q</code>: Fecha o editor.</li>
<li><code>:quit!</code> ou <code>:q!</code>: Fecha sem gravar.</li>
<li><code>:wq</code>: Salva e fecha.</li>
<li><code>:exit</code> ou <code>:x</code> ou <code>:e</code>: Fecha e grava, se necessário.</li>
<li><code>:visual</code>: Volta para o modo de comando.</li>
</ul>
<p>Existem versões do vi que possuem mais recursos, como o <em>vim</em> e até versões com interface gráfica, como o <em>gvim</em>. Contudo, o vi é suficiente para escrever arquivos de texto não formatado e scripts.</p>
</section>
<section id="início-do-script" class="level3">
<h3>Início do script</h3>
<p>A primeira linha do arquivo de script deve especificar o interpretador, que é indicado pelos caracteres <strong>#!</strong> (termo conhecido como <em>she-bang</em>). Para um script com instruções para o shell Bash, a primeira linha deverá ser <code>#!/bin/bash</code>. Assim, o interpretador para todas as instruções subsequentes será o programa <code>/bin/bash</code>. Com exceção da primeira linha, todas as demais linhas começando com <code>#</code> são ignoradas e podem ser utilizadas como lembretes e comentários.</p>
</section>
<section id="variáveis-especiais" class="level3">
<h3>Variáveis especiais</h3>
<p>Os argumentos passados para um script e outras informações úteis são retornados pela variável especial <em>$x</em>, em que <em>x</em> determina qual valor retornar:</p>
<ul>
<li><code>$*</code>: Todos os valores passados como argumentos.</li>
<li><code>$#</code>: O número de argumentos.</li>
<li><code>$0</code>: O nome do arquivo de script.</li>
<li><code>$n</code>: O valor do argumento na posição n. A variável <code>$1</code> corresponde ao primeiro argumento, <code>$2</code> ao segundo argumento e assim sucessivamente.</li>
<li><code>$!</code>: PID do último programa executado.</li>
<li><code>$$</code>: PID do shell atual.</li>
<li><code>$?</code>: Código numérico de saída do último comando. No padrão Unix, um código de saída igual a <code>0</code> significa que o último comando foi executado sem erros. O mesmo vale para o código de saída de scripts do shell.</li>
</ul>
<p>Para solicitar valores ao usuário durante a execução do script, é utilizada a instrução <code>read</code>:</p>
<pre><code>echo &quot;Informe valor solicitado:&quot;
read RESPOSTA</code></pre>
<p>O valor retornado será armazenado na variável <code>RESPOSTA</code>. Caso uma variável de retorno não seja especificada, o nome padrão da variável de retorno, <code>REPLY</code>, será utilizado. Para armazenar a saída de um comando em uma variável, são utilizadas as aspas invertidas:</p>
<pre><code>os=`uname -o`</code></pre>
<p>Para exibir o conteúdo da variável, é necessário incluir o <em>$</em> à frente de seu nome. As variáveis podem ser utilizadas para exibir valores ou internamente, para armazenar dados que serão avaliados pelo programa para tomada de decisões.</p>
</section>
<section id="tomada-de-decisão" class="level3">
<h3>Tomada de decisão</h3>
<p>A principal característica de qualquer programa é a execução de determinadas ações dependendo de circunstâncias pré-determinadas. Para essa tarefa, existe o operador <strong>if</strong>, que executa um comando ou uma lista de comandos se uma condição for verdadeira. A instrução <strong>test</strong> avalia se a condição é verdadeira ou falsa. Seu uso é geralmente associado ao operador <code>if</code>, como no exemplo a seguir, que exibe <em>ok</em> se o arquivo <code>/bin/bash</code> for executável:</p>
<pre><code>if test -x /bin/bash ; then
  echo &quot;ok&quot;
fi</code></pre>
<p>O exemplo a seguir mostra outra maneira de realizar a mesma tarefa:</p>
<pre><code>if [ -x /bin/bash ] ; then
  echo &quot;ok&quot;
fi</code></pre>
<p>A instrução <code>else</code> é opcional à estrutura <code>if</code> e determina o bloco de instruções a executar caso a afirmação avaliada seja falsa. Exemplo:</p>
<pre><code>if [ -x /bin/bash ] ; then
  echo &quot;ok&quot;
else
  echo &quot;não ok&quot;
fi</code></pre>
<p>O final da estrutura <code>if</code> deve ser sempre sinalizado com <code>fi</code>.</p>
<p>Existem opções do <code>test</code>para várias finalidades. A seguir, algumas opções de avaliação da instrução <code>test</code> para arquivos e diretórios, supondo que um caminho para um arquivo ou diretório foi armazenado na variável <em>$caminho</em>:</p>
<ul>
<li><code>-d $caminho</code>: Verdadeiro se o caminho existir e for um diretório.</li>
<li><code>-c $caminho</code>: Verdadeiro se o caminho existir.</li>
<li><code>-f $caminho</code>: Verdadeiro se o caminho existir e for um arquivo comum.</li>
<li><code>-L $caminho</code>: Verdadeiro se o caminho existir e for um link simbólico.</li>
<li><code>-r $caminho</code>: Verdadeiro se o caminho existir e puder ser lido (acessado).</li>
<li><code>-s $caminho</code>: Verdadeiro se o caminho existir e seu tamanho for maior que zero.</li>
<li><code>-w $caminho</code>: Verdadeiro se o caminho existir e puder ser escrito.</li>
<li><code>-x $caminho</code>: Verdadeiro se o caminho existir e for executável.</li>
<li><code>$caminho1 -ot $caminho2</code>: Verdadeiro se caminho1 for diferente de caminho2.</li>
</ul>
<p>Opções de avaliação de <code>test</code> para conteúdo de texto, supondo que a variável <em>$texto</em> contenha algum conteúdo:</p>
<ul>
<li><code>-n $texto</code>: Verdadeiro se o tamanho de texto for diferente de zero.</li>
<li><code>-z $texto</code>: Verdadeiro se o tamanho de texto for zero.</li>
<li><code>$texto1 == $texto2</code>: Verdadeiro se texto1 for igual a texto2.</li>
<li><code>$texto1 != $texto2</code>: Verdadeiro se texto1 for diferente de texto2.</li>
</ul>
<p>Opções de avaliação de <code>test</code> para números, supondo que <code>$num1</code> e <code>$num2</code> contenham valores numéricos:</p>
<ul>
<li><code>$num1 -lt $num2</code>: Verdadeiro se num1 for menor que num2.</li>
<li><code>$num1 -gt $num2</code>: Verdadeiro se num1 for maior que num2.</li>
<li><code>$num1 -le $num2</code>: Verdadeiro se num1 for menor ou igual a num2.</li>
<li><code>$num1 -ge $num2</code>: Verdadeiro se num1 for maior ou igual a num2.</li>
<li><code>$num1 -eq $num2</code>: Verdadeiro se num1 for igual a num2.</li>
<li><code>$num1 -ne $num2</code>: Verdadeiro se num1 for diferente de num2.</li>
</ul>
<p>Uma variação da instrução <code>if</code> é a instrução <code>case</code>. A instrução <code>case</code> prosseguirá se um item indicado for encontrado em uma lista de itens divididos pelo caractere barra vertical “|”. Supondo que a variável <em>$num</em> contenha o número 3:</p>
<pre><code>case $num in (1|2|3|4|5)
  echo &quot;Número $num encontrado na lista,&quot;;
  echo &quot;portanto case finalizou e&quot;;
  echo &quot;executou esses comandos&quot;;
esac</code></pre>
<p>O final da estrutura <code>case</code> deve ser sempre sinalizado com o termo <code>esac</code>.</p>
</section>
<section id="instruções-de-repetição" class="level3">
<h3>Instruções de repetição</h3>
<p>E bastante comum o desenvolvimento de scripts cuja finalidade é executar determinada tarefa repetidamente, obedecendo a uma condição pré-determinada. Para esse fim existem as chamadas instruções de repetição ou laço.</p>
<p>A instrução <code>for</code> executa uma ou mais ações para cada elemento de uma lista. Neste caso, cada número gerado pelo comando <code>seq</code>:</p>
<pre><code>for i in $(seq 5); do
  echo &quot;Copiando parte $i&quot;;
  scp luciano@lcnsqr.com:~/parte_$i ./;
done</code></pre>
<p>O comando <code>seq 5</code> gera a sequência numérica de 1 a 5, tomados um a um pelo <code>for</code> e atribuídos a variável <code>i</code>. Para cada item da lista - nesse caso, para cada número - será executada a sequência de comandos dentro do bloco até o termo <code>done</code>.</p>
<p>A instrução <code>until</code> executa a sequência de comandos até que uma afirmação seja verdadeira. Por exemplo, implementar a mesma repetição feita anteriormente com <code>for</code> agora com <code>until</code>:</p>
<pre><code>i=1; 
until [ $i -gt 5 ]; do 
  echo &quot;Copiando parte $i&quot;;
  scp luciano@lcnsqr.com:~/parte_$i ./;
  i=$(($i+1)); 
done</code></pre>
<p>O <code>until</code> geralmente é maior que seu equivalente em <code>for</code>, mas pode ser mais adequados em algumas situações. Seu critério de encerramento é mais versátil que o contador do <code>for</code>, pois aceita qualquer parâmetro do <code>test</code>.</p>
<p>A instrução <code>while</code> é semelhante à instrução <code>until</code>, mas executa uma ação até que a afirmação deixe de ser verdadeira:</p>
<pre><code>i=1; 
while [ $i -le 5 ]; do 
  echo &quot;Copiando parte $i&quot;;
  scp luciano@lcnsqr.com:~/parte_$i ./;
  i=$(($i+1)); 
done</code></pre>
<p>Este último exemplo produz o mesmo resultado da implementação com <code>until</code> no exemplo anterior.</p>
</section>
<section id="execução-do-script" class="level3">
<h3>Execução do script</h3>
<p>Caso o script vá ser compartilhado para execução por outros usuários, é importante que estes tenham acesso de leitura ao mesmo. O script do Bash pode ser executado invocando o comando <code>bash</code> tendo o caminho do script como argumento. Por exemplo, para executar o script <code>meuscript.sh</code> presente no diretório atual:</p>
<pre><code>$ bash meuscript.sh</code></pre>
<p>Alternativamente, o script pode ter a permissão de execução ser executado como um programa convencional. Para atribuir a permissão de execução a um script, é utilizado o comando <code>chmod</code>:</p>
<pre><code>$ chmod +x meuscript.sh</code></pre>
<p>Dessa forma, o arquivo do script <em>meuscript.sh</em> localizado no diretório atual poderá ser executado diretamente com o comando <code>./meuscript.sh</code>.</p>
</section>
</section>
</section>
</body>
</html>

